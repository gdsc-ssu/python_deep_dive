# 파이썬 리스트 vs 넘파이 다차원 배열

### 넘파이 다차원 배열

- 가장 큰 차이는 계산 성능
- 넘파이는 대용량의 배열과 연산을 수행하는 고차원적인 수학 연산자와 함수를 포함
- 동일한 자료형을 가진 데이터를 연속으로 저장 → 원소 접근 속도가 빠르다
- 선형대수의 벡터 개념
- 더하면 각각의 대치되는 원소들의 계산값이 나온다

### 파이썬 리스트

- 다양한 자료형이 들어간다 → 원소 접근 속도가 넘파이 다차원배열보다 느리다
- 단순한 데이터의 나열
- 더하면 concatinate 되버린다

![img/Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20vs%20%E1%84%82%E1%85%A5%E1%86%B7%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%20%E1%84%83%E1%85%A1%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%AF%E1%86%AB%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20690f18c1a08e42b3b565e4a1e43e1aa3/Untitled.png)

### 다차원 배열 과 브로드캐스팅

```cpp
np.full((2,3), 100) // 2행 3열의 행령 생성시 전부 100으로
np.eye(3) 3x3 크기의 단위행렬 생성
```

## 연속적인 값을 가지는 다차원 배열의 생성

### arange()

```python
np.arange(0,10) # 0~9 10 포함 안함
np.arange(0,10,2) # 0,2,4,6,8, 10포함 안함

np.arange(0.0,1.0,0.2) # 0과1사이의 0.2씩 증가하는 수열
```

### linspace()

```python
np.linspace(0,10,5) #0부터 10포함하여 5개의 요소의 값 사이를 균일하게
```

### logspace()

```python
np.logspace(0,2,num = 2) #0 부터 10 100 사이에 요소 3개를 생성합니다 즉 1, 10 , 100이 나옵니다
```

## 다차원 배열의 축과 삽입

### insert()

```python
a = np.array([1,3,4])
np.insert(a,1,2) # 1번째 요소에 2를 삽입합니다

#output : [1,2,3,4]
```

### 축 삽입

축에 알맞게 삽입이 진행됩니다.

```python
b = np.array([[1,1],[2,2],[3,3]])
np.insert(b,1,4,axis = 0) # 축 0을 기준으로

#[1,1],[4,4],[2,2],[3,3]

np.insert(b,1,4,axis = 1) # 축 1을 기준으로

'''
[[1,4,1],[2,4,2],[3,4,3]]
'''
```

### flip()

축 방향으로 원소들을 뒤집을 수 있다

```python
c = np.array([[1,2,3],[4,5,6]])
np.flip(c,axis=1)

'''
[3,2,1]
[6,5,4]
'''

np.flip(c,axis=0)
'''
[4,5,6]
[1,2,3]
'''

(::-1) 사용 가능
```

## 넘파이 배열의 인덱싱과 슬라이싱

```python
arr_2d[0][0] #0번째 행 0번째 열에 대해 요소들 전부 불러옵니다.
arr_2d[2] #2번째 행에 대한 요소들 전부 불러옵니다.
```

## 다차원 배열의 최대값, 최소값, 평균값 구하기와 정렬

```python
a = np.array([10,20,30])

a.max() , a.min()
a.mean() # 평균

a.astype(np.float64) #원소의 자료형을 float64로 변환
```

### 2차원에서 1차원으로 바꿔주는 flatten()

```python
b = np.array([[1,1],[2,2],[3,3]])
b.flatten()

# [1,1,2,2,3,3]
```

### 배열의 행과 열의 순서를 서로 교환하는  T

```python
b = np.array([[1,1],[2,2],[3,3]])
b.T
```

### 배열에 대한 정렬

```python
c = np.array([35,24,55,69,19,99])

c.sort() #배열의 정렬 (오름차순) -> none
c[::-1] #내림차순 정렬

b = np.array([[1,1],[2,2],[3,3]])
b.sort() # axis 1 방향으로 오름차순 정렬
b.sort(axis=0) # axis 0 방향으로 오름차순 정렬
```

## 다차원 배열을 위한 append() 함수와 행렬곱셈

```python
a = np.array([1,2,3])
b = np.array([[4,5,6], [7,8,9]])
np.append(a,b)

np.append([a], b, axis=0)
```

⇒ axis = 0 라고 명시해주면 같이 특정한 축으로 합하게 된다.

⇒ 명시하지 않으면 1차원 배열로 합쳐진다

- 행렬 곱셈은 행렬에 있는 행의 성분과 열의 성분을 가각 원소끼리 곱한 것을 더한 결과

### 행렬 곱 함수 : matmul()

```python
a = np.array([[1,2],[3,4]])
b = np.array([[10,20],[30,40]])

a*b
np.matmul(a,b) # 내적
a@b -> 내적 
```

## 배열의 형태를 바꾸는

### reshape()

```python
y = np.arange(12)
y = ([0,1,2,3,4,5,6,7,8,9,10,11])

y.reshape(3,4) #행 열 임을 잊지 말자 axis = 0 -> 3 axis = 1 -> 4
y.reshape(6,-1) #-1인자는 자동으로 맞춰준다

```

### flatten()

```python
y.flatten() -> 2차원 -> 1차원
```

## 난수

1. 실세계의 관측을 통해서 획득한 데이터 → 많은 비용과 장시간의 관측이 필요함
2. 실세계 데이터와 유사한 특성을 가지는 가상의 데이터

### 난수

난수 : 인간의 의도와 무관하게 생성된 수 → 난수를 생성하는 것 자체가 모순

의사 난수 : 매우 유사한 특징을 가지는 수를 생성하는 것은 가능 → 의사난수

<aside>
💡 아핀함수에 대해 mod m

</aside>

- 재현성을 위한 x 값은 seed 값으로 설정하고 나머지 a,b .m 은 임의값을 작성한다

### randint()

```python
np.random.randint(150,191, size = 10)
# size = 10인 150 ~ 190 (191 포함하지 않음)
```

### shuffle() : 함수의 순서를 섞는다

### permutation : 주어진 범위의 수를 생성하여 섞거나, 배열의 임의의 순서로 섞는다

## 넘파일 스타일의 슬라이싱 과 논리 인덱싱

- 축별로 적용이 가능하다

```python
arr_2d[1: , 0:2]
# axis0 1 부터 쭉 
# axis1 0 부터 쭉
```

⇒ subset을 추출하는데 도움이 된다.

### 논리 인덱싱

```python
np_array % 2 == 0
```

## 리덕션 : 여러 개의 수로 이루어진 배열을 하나의 수로 집계

집계를 위한 함수 : sum(), mean(), min(),max()

```python
np.sum(arr,axis = (0,1))
```

→ 속도가 엄청 빠르다

## 선형방정식풀기

```python
from numpy import linalg as apl

s = npl.solve(a,b)

det(s)
# 행렬의 행렬식을 간단하게 출력할 수 있다.
```

## 배열의 결합

### concatenate() : 두 리스트 결합

### vstack() : 수직방향으로 결합

### hstack() : 수평방향으로 결합

- hstack() axis 0 의 차원의 값이 동일한 값만 가능하다 → 높이가 다르면 계산할 수 없기 떄문

### r_, c_

r_ : 행결합 = hstack()

c_ : 열결합 = vstack()
